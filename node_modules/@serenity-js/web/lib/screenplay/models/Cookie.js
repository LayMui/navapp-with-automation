"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cookie = void 0;
const core_1 = require("@serenity-js/core");
const io_1 = require("@serenity-js/core/lib/io");
const tiny_types_1 = require("tiny-types");
const errors_1 = require("../../errors");
const abilities_1 = require("../abilities");
class Cookie {
    constructor(cookieName) {
        this.cookieName = cookieName;
        (0, tiny_types_1.ensure)('browser', cookieName, (0, tiny_types_1.isDefined)());
    }
    /**
     * @desc
     *  Creates a {@link @serenity-js/core/lib/screenplay~Question} about a Cookie
     *
     * @param {Answerable<string>} name
     * @returns {Question<Promise<Cookie>> & Adapter<Cookie>}
     */
    static called(name) {
        return core_1.Question.about(`"${name}" cookie`, async (actor) => {
            const cookieName = await actor.answer(name);
            return abilities_1.BrowseTheWeb.as(actor).cookie(cookieName);
        });
    }
    /**
     * @desc
     *  Sets a cookie for the current page.
     *  Make sure that the actor performing this interaction is on the page that should receive the cookie.
     *  An actor can't set a cookie for an arbitrary page without being on that page.
     *
     * @param {Answerable<CookieData>} cookieData
     * @returns {@serenity-js/core/lib/screenplay~Interaction}
     */
    static set(cookieData) {
        return core_1.Interaction.where((0, io_1.formatted) `#actor sets cookie: ${cookieData}`, async (actor) => {
            const cookie = (0, tiny_types_1.ensure)('cookieData', await actor.answer(cookieData), (0, tiny_types_1.isDefined)(), (0, tiny_types_1.isPlainObject)());
            const sanitisedCookieData = {
                name: (0, tiny_types_1.ensure)(`Cookie.set(cookieData.name)`, cookie.name, (0, tiny_types_1.isDefined)(), (0, tiny_types_1.isString)()),
                value: (0, tiny_types_1.ensure)(`Cookie.set(cookieData.value)`, cookie.value, (0, tiny_types_1.isDefined)(), (0, tiny_types_1.isString)()),
                path: ensureIfPresent(cookie, 'path', (0, tiny_types_1.isString)()),
                domain: ensureIfPresent(cookie, 'domain', (0, tiny_types_1.isString)()),
                secure: ensureIfPresent(cookie, 'secure', (0, tiny_types_1.isBoolean)()),
                httpOnly: ensureIfPresent(cookie, 'httpOnly', (0, tiny_types_1.isBoolean)()),
                expiry: ensureIfPresent(cookie, 'expiry', (0, tiny_types_1.isInstanceOf)(core_1.Timestamp)),
                sameSite: ensureIfPresent(cookie, 'sameSite', (0, tiny_types_1.isOneOf)('Lax', 'Strict', 'None')),
            };
            return abilities_1.BrowseTheWeb.as(actor).setCookie(sanitisedCookieData);
        });
    }
    /**
     * @desc
     *  Creates an {@link @serenity-js/core/lib/screenplay~Interaction} to delete all cookies currently set in the browser.
     *
     * @returns {@serenity-js/core/lib/screenplay~Interaction}
     */
    static deleteAll() {
        return core_1.Interaction.where(`#actor deletes all cookies`, actor => {
            return abilities_1.BrowseTheWeb.as(actor).deleteAllCookies();
        });
    }
    name() {
        return this.cookieName;
    }
    /**
     * @desc
     *  Checks if a given cookie is set.
     *
     * @returns {Promise<boolean>}
     */
    async isPresent() {
        try {
            const cookie = await this.lazyLoadCookie();
            return cookie && cookie.name === this.cookieName;
        }
        catch (error) {
            if (error instanceof errors_1.CookieMissingError) {
                return false;
            }
            throw error;
        }
    }
    /**
     * @desc
     *  Returns the value of a given cookie.
     *
     * @returns {Promise<string>}
     */
    async value() {
        const cookie = await this.lazyLoadCookie();
        return cookie.value;
    }
    /**
     * @desc
     *  Returns the path of a given cookie, if any was set.
     *
     * @returns {Promise<string>}
     */
    async path() {
        const cookie = await this.lazyLoadCookie();
        return cookie.path;
    }
    /**
     * @desc
     *  Returns the domain of a given cookie, if any was set.
     *
     * @returns {Promise<string>}
     */
    async domain() {
        const cookie = await this.lazyLoadCookie();
        return cookie.domain;
    }
    /**
     * @desc
     *  Checks if a given cookie is HTTP-only.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies
     *
     * @returns {Promise<string>}
     */
    async isHttpOnly() {
        const cookie = await this.lazyLoadCookie();
        return cookie.httpOnly;
    }
    /**
     * @desc
     *  Checks if a given cookie is secure.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies
     *
     * @returns {Promise<string>}
     */
    async isSecure() {
        const cookie = await this.lazyLoadCookie();
        return cookie.secure;
    }
    /**
     * @desc
     *  Returns the expiry date of a given cookie
     *
     * @returns {Promise<Timestamp>}
     */
    async expiry() {
        const cookie = await this.lazyLoadCookie();
        return cookie.expiry;
    }
    /**
     * @desc
     *  Invokes {@link Cookie#read} and caches the result in memory.
     *
     * @private
     * @returns {Promise<CookieData>}
     */
    async lazyLoadCookie() {
        if (!this.cookie) {
            this.cookie = await this.read();
        }
        return this.cookie;
    }
}
exports.Cookie = Cookie;
/**
 * @ignore
 * @private
 *
 * @param data
 * @param property
 * @param predicates
 */
function ensureIfPresent(data, property, ...predicates) {
    return data[property] !== undefined
        ? (0, tiny_types_1.ensure)(`Cookie.set(cookieData.${property})`, data[property], ...predicates)
        : undefined;
}
//# sourceMappingURL=Cookie.js.map