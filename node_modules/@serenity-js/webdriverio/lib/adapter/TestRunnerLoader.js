"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestRunnerLoader = void 0;
const core_1 = require("@serenity-js/core");
const io_1 = require("@serenity-js/core/lib/io");
/**
 * @package
 */
class TestRunnerLoader {
    constructor(loader, cwd, cid) {
        this.loader = loader;
        this.cwd = cwd;
        this.cid = cid;
        this.fileSystem = new io_1.FileSystem(cwd);
        this.finder = new io_1.FileFinder(cwd);
    }
    runnerAdapterFor(config) {
        var _a, _b;
        switch ((_a = config === null || config === void 0 ? void 0 : config.serenity) === null || _a === void 0 ? void 0 : _a.runner) {
            case 'cucumber':
                return this.cucumberAdapter(config === null || config === void 0 ? void 0 : config.cucumberOpts);
            case 'jasmine':
                return this.jasmineAdapter(config === null || config === void 0 ? void 0 : config.jasmineOpts);
            case 'mocha':
            case undefined:
                return this.mochaAdapter(config === null || config === void 0 ? void 0 : config.mochaOpts);
            default:
                throw new core_1.ConfigurationError(`"${(_b = config === null || config === void 0 ? void 0 : config.serenity) === null || _b === void 0 ? void 0 : _b.runner}" is not a supported test runner. Please use "mocha", "jasmine", or "cucumber"`);
        }
    }
    cucumberAdapter(cucumberOptions) {
        var _a;
        const { CucumberCLIAdapter, CucumberFormat, StandardOutput, TempFileOutput } = this.loader.require('@serenity-js/cucumber/lib/cli');
        cucumberOptions === null || cucumberOptions === void 0 ? true : delete cucumberOptions.timeout; // todo: support setting a timeout via config?
        cucumberOptions === null || cucumberOptions === void 0 ? true : delete cucumberOptions.parallel; // WebdriverIO handles that already
        const cleanedCucumberOptions = new io_1.Config(cucumberOptions)
            .where('require', requires => this.finder.filesMatching(requires).map(p => p.value))
            .where('format', values => [].concat(values).map(value => {
            const format = new CucumberFormat(value);
            if (format.output === '') {
                return format.value;
            }
            const basename = io_1.Path.from(format.output).basename();
            const filenameParts = basename.split('.');
            if (filenameParts[0] === basename) {
                return `${format.formatter}:${format.output}.${this.cid}`;
            }
            filenameParts.splice(-1, 0, `${this.cid}`);
            return `${format.formatter}:${format.output.replace(basename, filenameParts.join('.'))}`;
        })).object();
        // check if we need to free up stdout for any native reporters
        const output = ((_a = cleanedCucumberOptions === null || cleanedCucumberOptions === void 0 ? void 0 : cleanedCucumberOptions.format) === null || _a === void 0 ? void 0 : _a.some(format => new CucumberFormat(format).output === ''))
            ? new TempFileOutput(this.fileSystem)
            : new StandardOutput();
        return new CucumberCLIAdapter(cleanedCucumberOptions, this.loader, this.fileSystem, output);
    }
    jasmineAdapter(jasmineOptions) {
        const { JasmineAdapter } = this.loader.require('@serenity-js/jasmine/lib/adapter');
        return new JasmineAdapter(jasmineOptions, this.loader);
    }
    mochaAdapter(mochaOptions) {
        const { MochaAdapter } = this.loader.require('@serenity-js/mocha/lib/adapter');
        return new MochaAdapter(mochaOptions, this.loader);
    }
}
exports.TestRunnerLoader = TestRunnerLoader;
//# sourceMappingURL=TestRunnerLoader.js.map